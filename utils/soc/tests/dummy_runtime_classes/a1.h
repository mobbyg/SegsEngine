#pragma once

#include "core/reflection_macros.h"

#include <stdint.h>
#include <utility>

SE_NAMESPACE(TestNS)

struct Simple {
    SE_CLASS(struct)
};


struct Complex {
    SE_CLASS()

    SE_INVOCABLE void callme();
};

struct SEMetaObjectPrivate
{
    int revision;
    int className;
    int classInfoCount, classInfoData;
    int methodCount, methodData;
    int propertyCount, propertyData;
    int enumeratorCount, enumeratorData;
    int constructorCount, constructorData;
    int flags;
    int signalCount;
};
static inline const SEMetaObjectPrivate *priv(const uint32_t* data)
{
    return reinterpret_cast<const SEMetaObjectPrivate*>(data);
}

struct SEMetaObject {
    int methodCount() const {
        int n = priv(d.data)->methodCount;
        const SEMetaObject *m = d.superdata;
        while (m) {
            n += priv(m->d.data)->methodCount;
            m = m->d.superdata;
        }
        return n;
    }

    template <const SEMetaObject &MO> static constexpr const SEMetaObject *staticMetaObject()
    {
        return &MO;
    }
    struct SuperData {
        const SEMetaObject *direct;
        SuperData() = default;
        constexpr SuperData(std::nullptr_t) : direct(nullptr) {}
        constexpr SuperData(const SEMetaObject *mo) : direct(mo) {}

        constexpr const SEMetaObject *operator->() const { return operator const SEMetaObject *(); }

        constexpr operator const SEMetaObject *() const
        { return direct; }
        template <const SEMetaObject &MO> static constexpr SuperData link()
        { return SuperData(SEMetaObject::staticMetaObject<MO>()); }
    };

    struct { // private data
        SuperData superdata;
        const char *stringdata;
        const uint32_t *data;
    } d;
};


struct IReflectable {
    virtual bool hasDynamicMetaObject() const { return false; };
    virtual SEMetaObject *dynamicMetaObject() const { return nullptr; };
};

// implemented by files generated by soc.cpp
template<class T>
SEMetaObject *getMetaObject(T *self);


